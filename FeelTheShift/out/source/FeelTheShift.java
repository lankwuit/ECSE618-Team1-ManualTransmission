/* autogenerated by Processing revision 1277 on 2023-02-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import org.jbox2d.collision.*;
import org.jbox2d.collision.shapes.*;
import org.jbox2d.common.*;
import org.jbox2d.dynamics.*;
import org.jbox2d.dynamics.contacts.*;
import org.jbox2d.dynamics.controllers.*;
import org.jbox2d.dynamics.joints.*;
import org.jbox2d.pooling.*;
import org.jbox2d.pooling.arrays.*;
import org.jbox2d.pooling.stacks.*;
import org.jbox2d.util.blob.*;
import org.jbox2d.util.nonconvex.*;
import org.jbox2d.util.sph.*;

import processing.serial.*;
import static java.util.concurrent.TimeUnit.*;
import java.util.concurrent.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class FeelTheShift extends PApplet {

/* library imports *****************************************************************************************************/ 



/* end library imports *************************************************************************************************/  



/* scheduler definition ************************************************************************************************/ 
private final ScheduledExecutorService scheduler      = Executors.newScheduledThreadPool(1);
/* end scheduler definition ********************************************************************************************/  



/* device block definitions ********************************************************************************************/
Board             haplyBoard;
Device            widgetOne;
Mechanisms        pantograph;

byte              widgetOneID                         = 5;
int               CW                                  = 0;
int               CCW                                 = 1;
boolean           rendering_force                     = false;
/* end device block definition *****************************************************************************************/



/* framerate definition ************************************************************************************************/
long              baseFrameRate                       = 120;
/* end framerate definition ********************************************************************************************/ 



/* elements definition *************************************************************************************************/

/* Screen and world setup parameters */
float             pixelsPerCentimeter                 = 40.0f;

/* data for a 2DOF device */
/* joint space */
PVector           angles                              = new PVector(0, 0);
PVector           torques                             = new PVector(0, 0);

/* task space */
PVector           pos_ee                              = new PVector(0, 0);
PVector           f_ee                                = new PVector(0, 0); 

/* world size in pixels */
int w = 1000;
int h = 400;


/* World boundaries in centimeters*/
FWorld            world;
float             worldWidth                          = w/pixelsPerCentimeter;  
float             worldHeight                         = h/pixelsPerCentimeter;

float             edgeTopLeftX                        = 0.0f; 
float             edgeTopLeftY                        = 0.0f; 
float             edgeBottomRightX                    = worldWidth; 
float             edgeBottomRightY                    = worldHeight;

/* joints to be created for avatar */
boolean           jointCreated                        = false;
FDistanceJoint    d1;

/* Initialization of virtual tool */
HVirtualCoupling  s;
FCircle           h1; // grab radius

/* define gear mechanisim */
GearShifter mechanisim;



/* region information */
int region = -1;

/* angle for region 2 */
float theta = 0;
float radius = 1.0f;

/* end elements definition *********************************************************************************************/  



/* setup section *******************************************************************************************************/
 public void setup(){
  /* put setup code here, run once: */
  
  /* screen size definition */
  /* size commented out by preprocessor */;
  /* device setup */
  
  /**  
   * The board declaration needs to be changed depending on which USB serial port the Haply board is connected.
   * In the base example, a connection is setup to the first detected serial device, this parameter can be changed
   * to explicitly state the serial port will look like the following for different OS:
   *
   *      windows:      haplyBoard = new Board(this, "COM10", 0);
   *      linux:        haplyBoard = new Board(this, "/dev/ttyUSB0", 0);
   *      mac:          haplyBoard = new Board(this, "/dev/cu.usbmodem1411", 0);
   */
  //haplyBoard          = new Board(this, Serial.list()[0], 0);
  //widgetOne           = new Device(widgetOneID, haplyBoard);
  //pantograph          = new Pantograph();
  
  //widgetOne.set_mechanism(pantograph);
  
  //start: added to fix inverse motion of the ball
  // widgetOne.add_actuator(1, CCW, 2);
  // widgetOne.add_actuator(2, CW, 1);

  // widgetOne.add_encoder(1, CCW, 241, 10752, 2);
  // widgetOne.add_encoder(2, CW, -61, 10752, 1);
  
  //end: added to fix inverse motion of the ball
  
  //widgetOne.add_analog_sensor("A1");
  
  //widgetOne.device_set_parameters();
  
  
  /* 2D physics scaling and world creation */
  hAPI_Fisica.init(this); 
  hAPI_Fisica.setScale(pixelsPerCentimeter); 
  world               = new FWorld();

  mechanisim = new GearShifter(1000, 400, world, pixelsPerCentimeter);
  
  
  

  
  /* Haptic Tool Initialization */
  s                   = new HVirtualCoupling((2.0f)); 
  s.h_avatar.setDensity(10);
  s.h_avatar.setStroke(0); 
  s.h_avatar.setFill(0); 
  //s.h_avatar.setSensor(true);
  s.init(world, edgeTopLeftX+worldWidth/2, edgeTopLeftY+worldHeight/2);
  
  
  
  /* world conditions setup */ 
  world.setGravity((0.0f), (300.0f)); //1000 cm/(s^2)
  //world.setEdges((edgeTopLeftX), (edgeTopLeftY), (edgeBottomRightX), (edgeBottomRightY)); 
  world.setEdgesRestitution(.4f);
  world.setEdgesFriction(0.5f);
  
  world.draw();

  mechanisim.draw();
  
  
  /* setup framerate speed */
  frameRate(baseFrameRate);
  
  
  /* setup simulation thread to run at 1kHz */ 
  //SimulationThread st = new SimulationThread();
  //scheduler.scheduleAtFixedRate(st, 1, 1, MILLISECONDS);
}
/* end setup section ***************************************************************************************************/



/* draw section ********************************************************************************************************/
 public void draw(){
  /* put graphical code here, runs repeatedly at defined framerate in setup, else default at 60fps: */
  background(255);
  world.draw();  
}
/* end draw section ****************************************************************************************************/




/* simulation section **************************************************************************************************/
class SimulationThread implements Runnable{
  
  public void run(){
    /* put haptic simulation code here, runs repeatedly at 1kHz as defined in setup */
    
    rendering_force = true;
    
    if(haplyBoard.data_available()){
      
      /* GET END-EFFECTOR STATE (TASK SPACE) */
      widgetOne.device_read_data();
    
      angles.set(widgetOne.get_device_angles()); 
      pos_ee.set(widgetOne.get_device_position(angles.array()));
      pos_ee.set(pos_ee.copy().mult(200));  
    }
    


    
    s.setToolPosition(edgeTopLeftX+worldWidth/2-(pos_ee).x+2, edgeTopLeftY+(pos_ee).y-7); 
    s.updateCouplingForce();
    f_ee.set(-s.getVCforceX(), s.getVCforceY());
 
    f_ee.div(20000); //
    torques.set(widgetOne.set_device_torques(f_ee.array()));
    widgetOne.device_write_torques();
 
  
    world.step(1.0f/1000.0f);
  
    rendering_force = false;
  }
}
/* end simulation section **********************************************************************************************/



/* end helper functions section ****************************************************************************************/







// class the creates and displays the gear shifting mechanisim
public class GearShifter{

    int w,h; // width and height of the canvas in pixels
    float slotA_W = 0.1f;
    float slotA_h = 0.20f;

    float slotE_W2 = 0.15f - slotA_W;

    float xa = 0.5f-0.45f/2, ya = 0.15f; // coordinate for A
    float yb = 0.05f; // y coordinate for B

    float yaa = 1 - ya;
    float ybb = 1 - yb;

    float scale = 1.0f;
    FWorld world;
    FLine myLine;



    // the coordinates of curve to draw; must have 2n enteries so that (x/w,y/h) = topCoords[i], topCoords[i+1]
    // top left to top right
    float[] topCoords = {
        xa,                                 ya,                                 // A
        xa + slotA_W/2,                     yb,                                 // B
        xa + slotA_W,                       ya,                                 // C
        xa + slotA_W,                       ya + slotA_h,                       // D
        xa + slotA_W + slotE_W2*0.75f,       ya + slotA_h + slotE_W2,            // E
        xa + slotA_W + slotE_W2*1.5f,        ya + slotA_h,                       // F

        xa                              + (slotA_W + slotE_W2*1.5f),        ya,                                 // G
        xa + slotA_W/2                  + (slotA_W + slotE_W2*1.5f),        yb,                                 // H
        xa + slotA_W                    + (slotA_W + slotE_W2*1.5f),        ya,                                 // I
        xa + slotA_W                    + (slotA_W + slotE_W2*1.5f),        ya + slotA_h,                       // J
        xa + slotA_W + slotE_W2*0.75f    + (slotA_W + slotE_W2*1.5f),        ya + slotA_h + slotE_W2,            // K
        xa + slotA_W + slotE_W2*1.5f     + (slotA_W + slotE_W2*1.5f),        ya + slotA_h,                       // L

        xa                              + 2*(slotA_W + slotE_W2*1.5f),        ya,                                 // M
        xa + slotA_W/2                  + 2*(slotA_W + slotE_W2*1.5f),        yb,                                 // N
        xa + slotA_W                    + 2*(slotA_W + slotE_W2*1.5f),        ya,                                 // O

    };

    // going from bottom left to bottom right
    float[] bottomCoords = {
        xa,                                 yaa,                                 // A
        xa + slotA_W/2,                     ybb,                                 // B
        xa + slotA_W,                       yaa,                                 // C
        xa + slotA_W,                       yaa - slotA_h,                       // D
        xa + slotA_W + slotE_W2*0.75f,       yaa - slotA_h - slotE_W2,            // E
        xa + slotA_W + slotE_W2*1.5f,        yaa - slotA_h,                       // F

        xa                              + (slotA_W + slotE_W2*1.5f),        yaa,                                 // G
        xa + slotA_W/2                  + (slotA_W + slotE_W2*1.5f),        ybb,                                 // H
        xa + slotA_W                    + (slotA_W + slotE_W2*1.5f),        yaa,                                 // I
        xa + slotA_W                    + (slotA_W + slotE_W2*1.5f),        yaa - slotA_h,                       // J
        xa + slotA_W + slotE_W2*0.75f    + (slotA_W + slotE_W2*1.5f),        yaa - slotA_h - slotE_W2,            // K
        xa + slotA_W + slotE_W2*1.5f     + (slotA_W + slotE_W2*1.5f),        yaa - slotA_h,                       // L

        xa                              + 2*(slotA_W + slotE_W2*1.5f),        yaa,                                 // M
        xa + slotA_W/2                  + 2*(slotA_W + slotE_W2*1.5f),        ybb,                                 // N
        xa + slotA_W                    + 2*(slotA_W + slotE_W2*1.5f),        yaa,                                 // O

    };

    // constructor
    public GearShifter(int w, int h, FWorld world, float pixelsPerCm){
        this.w = w - 1;
        this.h = h - 1;

        this.world = world;
        this.scale = 1.0f/pixelsPerCm;
    }


    public void draw(){
        noFill();
        stroke(0);

        // top half
        for (int i = 0; i < topCoords.length; i += 2) { // draw the curve

            if(i > 0 && abs(topCoords[i] - topCoords[i-2]) < 0.001f){
                line(this.w * topCoords[i-2], this.h * topCoords[i - 1], this.w * topCoords[i], this.h * topCoords[i + 1]);
            }
            else if(i > 2 && (topCoords[i+1] - topCoords[i+1-2]) > 0 && abs(topCoords[i+1] - topCoords[i+1-2 -2]) < 0.00001f ){ // top arcs
                ellipseMode(RADIUS);
                arc(this.w * topCoords[i- 2], this.h * topCoords[i + 1 - 2 - 2], 0.5f*slotA_W*this.w, (ya - yb)*this.h, PI, 2*PI);
            }
            else if(i > 2 && (topCoords[i+1] - topCoords[i+1-2]) < 0 && abs(topCoords[i+1] - topCoords[i+1-2 -2]) < 0.00001f ){ // bottom arcs
                ellipseMode(RADIUS);
                arc(this.w * topCoords[i- 2], this.h * topCoords[i + 1 - 2 - 2], 0.75f*slotE_W2*this.w, slotE_W2*this.h, 2*PI, 3*PI);
            }
        }

        // bottom half
        for (int i = bottomCoords.length - 4; i >= 0; i -= 2) { // draw the curve

            if(abs(bottomCoords[i] - bottomCoords[i+2]) < 0.001f){ // compare this and previous one
                line(this.w * bottomCoords[i+2], this.h * bottomCoords[i + 1 + 2], this.w * bottomCoords[i], this.h * bottomCoords[i + 1]);
            }
            else if(i < bottomCoords.length - 4 && (bottomCoords[i+1] - bottomCoords[i+1+2]) > 0 && abs(bottomCoords[i+1] - bottomCoords[i+1 + 2 + 2]) < 0.00001f ){ // top arcs
                ellipseMode(RADIUS);
                arc(this.w * bottomCoords[i + 2], this.h * bottomCoords[i + 1 + 2 + 2], 0.75f*slotE_W2*this.w, slotE_W2*this.h, PI, 2*PI);
            }
            else if(i < bottomCoords.length - 4 && (bottomCoords[i+1] - bottomCoords[i+1 + 2]) < 0 && abs(bottomCoords[i+1] - bottomCoords[i+1 + 2 + 2]) < 0.00001f ){ // bottom arcs
                ellipseMode(RADIUS);
                arc(this.w * bottomCoords[i + 2], this.h * bottomCoords[i + 1 + 2 + 2], 0.5f*slotA_W*this.w, (ya - yb)*this.h, 2*PI, 3*PI);
            }
        }


        // side lines
        line(this.w * topCoords[0], this.h * topCoords[1], this.w * bottomCoords[0], this.h * bottomCoords[1]);
        line(this.w * topCoords[topCoords.length - 2], this.h * topCoords[topCoords.length - 1], this.w * bottomCoords[bottomCoords.length - 2], this.h * bottomCoords[bottomCoords.length - 1]);



        FLine leftLine = new FLine(this.scale * this.w * topCoords[0], this.scale * this.h * topCoords[1], this.scale * this.w * bottomCoords[0], this.scale * this.h * bottomCoords[1]);
        FLine rightLine = new FLine(this.scale * this.w * topCoords[topCoords.length - 2], this.scale * this.h * topCoords[topCoords.length - 1],
        this.scale * this.w * bottomCoords[bottomCoords.length - 2], this.scale * this.h * bottomCoords[bottomCoords.length - 1]);

        this.world.add(leftLine);
        this.world.add(rightLine);

        fill(255, 0, 0);
        noStroke();
        ellipseMode(CENTER);
        for (int i = 0; i < topCoords.length; i += 2) { // show the coordinate points chosen in red
            ellipse(this.w * topCoords[i], this.h * topCoords[i + 1], 3, 3);
        }

        fill(0, 255, 0);
        for (int i = bottomCoords.length - 2; i >= 0; i -= 2) { // // show the coordinate points chosen in green
            ellipse(this.w * bottomCoords[i], this.h * bottomCoords[i + 1], 3, 3);
        }
    }

}


  public void settings() { size(1000, 400); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "FeelTheShift" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
